from __future__ import annotations

import datetime
from typing import List, Optional, Tuple
from dataclasses import dataclass, field # For Bar dataclass
import uuid # For replay_id

from pydantic import BaseModel, Field, ConfigDict, field_validator

# Using existing Instrument and Direction enums if applicable, or define new ones if needed
from azr_planner.schemas import Instrument, Direction


@dataclass(frozen=True)
class Bar:
    """Represents a single market data bar."""
    timestamp: datetime.datetime = field(compare=True) # Primary sort key
    instrument: str # Instrument identifier string (e.g., "MESU24", "EURUSD")
    open: float
    high: float
    low: float
    close: float
    volume: Optional[float] = None

    # Ensure H >= L, and Open/Close are within [L, H]
    # Dataclasses don't have Pydantic-style validators by default,
    # __post_init__ can be used for validation if needed, or rely on upstream data quality.
    # For simplicity, we'll assume valid OHLC data is fed.


class ReplayTrade(BaseModel):
    """Record of a decision and its outcome during replay."""
    bar_timestamp: datetime.datetime = Field(description="Timestamp of the bar on which the decision was made.")
    instrument_id: str = Field(description="Identifier of the instrument for which the proposal was generated (from PlanningContext).")
    proposal_action: str = Field(description="Action from the TradeProposal (e.g., ENTER, EXIT, HOLD).")
    proposal_legs_json: str = Field(description="JSON string representation of the legs in the TradeProposal.")
    accepted_by_risk_gate: bool = Field(description="Whether the proposal was accepted by the risk gate.")
    rejection_reason: Optional[str] = Field(default=None, description="Reason for risk gate rejection, if any.")

    # Execution details (simplified: assume fill at bar close if accepted)
    simulated_execution_price: Optional[float] = Field(default=None, description="Simulated execution price (e.g., bar close).")
    # pnl_impact refers to the immediate P&L from this specific trade action if it closes a position.
    # Overall portfolio P&L is tracked in the ReplayReport's equity curve.
    pnl_from_trade: Optional[float] = Field(default=None, description="Realized P&L if this trade closed/reduced a position.")

    planner_decision_ms: float = Field(description="Time taken by the planner function in milliseconds.")

    model_config = ConfigDict(populate_by_name=True, frozen=True)


class ReplayReport(BaseModel):
    """Summary report of a historical replay run."""
    replay_id: str = Field(default_factory=lambda: str(uuid.uuid4()), description="Unique ID for this replay run.")
    source_file: str = Field(description="Path or identifier of the input bar data file.")

    replay_start_time_utc: datetime.datetime = Field(description="Wall-clock time when the replay process started (UTC).")
    replay_end_time_utc: datetime.datetime = Field(description="Wall-clock time when the replay process finished (UTC).")
    replay_duration_seconds: float = Field(description="Total wall-clock duration of the replay run in seconds.")

    data_start_timestamp: Optional[datetime.datetime] = Field(default=None, description="Timestamp of the first bar processed.")
    data_end_timestamp: Optional[datetime.datetime] = Field(default=None, description="Timestamp of the last bar processed.")
    total_bars_processed: int = Field(default=0, description="Total number of market data bars processed.")

    proposals_generated: int = Field(default=0, description="Total number of trade proposals generated by the planner.")
    proposals_accepted: int = Field(default=0, description="Number of proposals accepted by the risk gate.")
    proposals_rejected: int = Field(default=0, description="Number of proposals rejected by the risk gate.")

    initial_equity: float = Field(description="Starting equity for the replay.")
    final_equity: float = Field(description="Ending equity after the replay.")
    total_return_pct: float = Field(description="Total return percentage over the replay period.")
    max_drawdown_pct: float = Field(description="Maximum drawdown percentage observed during the replay.")
    # sharpe_ratio: Optional[float] = Field(default=None, description="Sharpe ratio for the replay period (annualized).") # Requires risk-free rate & daily returns
    # For simplicity, Sharpe might be harder if bar data is not daily. Placeholder for now.

    mean_planner_decision_ms: Optional[float] = Field(default=None, description="Average time taken by the planner per decision in milliseconds.")

    # Equity curve: list of (timestamp, equity_value) tuples
    equity_curve: List[Tuple[datetime.datetime, float]] = Field(default_factory=list, description="Time series of portfolio equity values at each bar.")

    model_config = ConfigDict(populate_by_name=True, frozen=True)
