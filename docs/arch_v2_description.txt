# Architecture v2 Description

This document describes the components and interactions of the v2 architecture, intended to guide the creation of a Draw.io diagram (`arch_v2.drawio`) and its corresponding PNG image (`arch_v2.png`).

## Core Components:

1.  **LLM Sidecar (`server.py`) Container:**
    *   Hosts multiple Large Language Models.
    *   Exposes HTTP RESTful API endpoints for synchronous interactions.
    *   Interacts with the Redis Bus for asynchronous event handling (subscribing to specific events).
    *   Manages model loading, including dynamic adapter updates for Phi-3.

2.  **Hermes 8B Model:**
    *   A core Large Language Model.
    *   Hosted within the LLM Sidecar.
    *   Accessed via specific HTTP endpoints on the sidecar (e.g., `/generate?model_id=hermes`, or implicitly via `/propose_trade_adjustments`).
    *   Represented as a distinct model component inside the Sidecar.

3.  **Phi-3 Model + QLoRA Adapters:**
    *   Another core Large Language Model, specialized for structured JSON output.
    *   Hosted within the LLM Sidecar.
    *   Accessed via specific HTTP endpoints on the sidecar (e.g., `/generate?model_id=phi3`, or implicitly via `/propose_trade_adjustments`).
    *   **Key Feature**: Fine-tuned using QLoRA. Adapters are updated periodically (e.g., nightly) based on feedback.
    *   Represented as a model component with an attached "Adapter" symbol inside the Sidecar.

4.  **Redis Bus (Event Bus):**
    *   Central message broker for asynchronous communication between components.
    *   Uses Redis Pub/Sub.
    *   Handles various event types, including:
        *   `phi3.proposal.created`
        *   `phi3.proposal.assessed`
        *   `phi3.feedback.submitted`
    *   Represented as a central bus or queue symbol.

5.  **Orchestrator (`osiris_policy.orchestrator`):**
    *   A Python application/script that implements a defined workflow (policy).
    *   Runs as a separate process (e.g., CLI invocation, or could be a service).
    *   Interacts with the LLM Sidecar's HTTP endpoints for decision-making steps.
    *   Publishes events to the Redis Bus.
    *   Logs its execution runs to LanceDB.

6.  **LanceDB:**
    *   A persistent storage solution.
    *   Stores:
        *   User feedback data (collected via `phi3.feedback.submitted` event or directly).
        *   Orchestrator run logs.
    *   Accessed by the LLM Sidecar (for writing feedback) and the Orchestrator (for writing run logs). Conceptually, also accessed by the Nightly QLoRA process (for reading feedback).
    *   Represented as a database symbol.

7.  **User/Client:**
    *   External entity interacting with the system.
    *   Can initiate requests to the Orchestrator (e.g., via its CLI).
    *   Can submit feedback via an HTTP endpoint on the LLM Sidecar (e.g., `/feedback/phi3/`).

8.  **Nightly QLoRA Fine-Tuning Process (Conceptual):**
    *   A background, scheduled process (e.g., a cron job, a separate script).
    *   Reads feedback data from LanceDB.
    *   Performs QLoRA fine-tuning on the Phi-3 model using this data.
    *   Produces updated Phi-3 adapters.
    *   These updated adapters are then loaded by the LLM Sidecar (mechanism for this update can be a simple file watch, a trigger, or manual).
    *   Represented as a batch process or a timed-trigger component.

## Interactions and Flows:

**Flow 1: Orchestrator Workflow Execution**

1.  **User/Client** invokes the **Orchestrator** with a query (e.g., `python -m osiris_policy.orchestrator "user query"`).
2.  **Orchestrator** performs initial processing (e.g., `QueryMarket` node - currently mocked).
3.  **Orchestrator** sends an HTTP request to **LLM Sidecar** endpoint `/generate?model_id=phi3` (containing the market data/prompt).
    *   Arrow: Orchestrator -> LLM Sidecar (HTTP: `/generate?model_id=phi3`)
4.  **LLM Sidecar** routes the request to the **Phi-3 Model**.
5.  **Phi-3 Model** generates a proposal (JSON).
6.  **LLM Sidecar** returns the Phi-3 JSON proposal to the **Orchestrator**.
7.  **Orchestrator** sends another HTTP request to **LLM Sidecar** endpoint `/propose_trade_adjustments` (containing the original user query or context that leads to the proposal).
    *   Arrow: Orchestrator -> LLM Sidecar (HTTP: `/propose_trade_adjustments`)
8.  **LLM Sidecar** internally:
    *   Calls **Phi-3 Model** to generate/regenerate a proposal based on the prompt.
    *   Calls **Hermes 8B Model** to assess the generated Phi-3 proposal.
9.  **LLM Sidecar** returns a combined response (Phi-3 proposal + Hermes assessment) to the **Orchestrator**.
10.  **Orchestrator** receives the response.
11.  **Orchestrator** publishes events to **Redis Bus**:
    *   `phi3.proposal.created` (payload: Phi-3 proposal JSON from `/propose_trade_adjustments` response)
        *   Arrow: Orchestrator -> Redis Bus (Event: `phi3.proposal.created`)
    *   `phi3.proposal.assessed` (payload: Hermes assessment JSON + transaction ID)
        *   Arrow: Orchestrator -> Redis Bus (Event: `phi3.proposal.assessed`)
12.  **Orchestrator** logs the execution details (input, output, status) to **LanceDB**.
    *   Arrow: Orchestrator -> LanceDB (Write: Run Log)
13.  **Orchestrator** outputs the final result to the **User/Client** (stdout).

**Flow 2: Feedback Submission and Processing**

1.  **User/Client** submits feedback (e.g., correction, rating) via an HTTP POST request to **LLM Sidecar** endpoint `/feedback/phi3/`.
    *   Arrow: User/Client -> LLM Sidecar (HTTP: `/feedback/phi3/`)
2.  **LLM Sidecar** receives the feedback.
3.  **LLM Sidecar** publishes the `phi3.feedback.submitted` event to the **Redis Bus** (payload: feedback data).
    *   Arrow: LLM Sidecar -> Redis Bus (Event: `phi3.feedback.submitted`)
4.  **LLM Sidecar** (itself, through an internal event handler subscribed to `phi3.feedback.submitted` from the previous step, or directly in the endpoint handler) writes the feedback data to **LanceDB**.
    *   Arrow: Redis Bus -> LLM Sidecar (Subscribes to `phi3.feedback.submitted`)
    *   Arrow: LLM Sidecar -> LanceDB (Write: Feedback Data)

**Flow 3: Nightly QLoRA Fine-Tuning (Conceptual)**

1.  The **Nightly QLoRA Fine-Tuning Process** (automated script/job) triggers.
2.  It reads feedback data accumulated in **LanceDB**.
    *   Arrow: LanceDB -> Nightly QLoRA Process (Read: Feedback Data)
3.  The process uses this data to fine-tune the **Phi-3 Model**, generating new **QLoRA Adapters**.
    *   Arrow: Nightly QLoRA Process -> Phi-3 Adapters (Update/Create)
4.  The **LLM Sidecar** loads these updated **Phi-3 Adapters**. This could be on startup, via a trigger, or a periodic check.
    *   Arrow: Phi-3 Adapters -> LLM Sidecar (Load Adapters)

## Diagram Layout Notes:

*   Place the **LLM Sidecar** prominently, perhaps as a larger container.
*   Show **Hermes 8B** and **Phi-3 + Adapters** as components *inside* the LLM Sidecar.
*   Position the **Redis Bus** centrally, with event arrows flowing in and out.
*   The **Orchestrator** should be distinct from the Sidecar, interacting with it via HTTP and with Redis.
*   **LanceDB** should be shown as a persistent store, accessed by multiple components.
*   Arrows should be labeled with the type of interaction (HTTP, Event name, Data type like "Run Log" or "Feedback Data").
*   Use dotted lines or a different color for conceptual flows like the Nightly QLoRA process if it's not a direct, real-time interaction with the core request-response cycle.

